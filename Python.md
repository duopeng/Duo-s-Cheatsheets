### Parallel computing
```
#generated by ChatGPT

import multiprocessing

def worker(num, event, conn):
    """Worker function"""
    print(f"Worker {num} is running")
    result = num * 2
    conn.send(result)
    conn.close()
    event.set()

def main():
    processes = []
    parent_conns = []
    events = []
    results = []

    for i in range(5):
        parent_conn, child_conn = multiprocessing.Pipe()
        event = multiprocessing.Event()
        process = multiprocessing.Process(target=worker, args=(i, event, child_conn))
        processes.append(process)
        parent_conns.append(parent_conn)
        events.append(event)
        process.start()

    for i in range(5):
        events[i].wait()
        results.append(parent_conns[i].recv())
        processes[i].join()

    print("All processes are done")
    print(f"Results: {results}")

if __name__ == "__main__":
    main()
```
```
#version 2 with logging
def worker(arg1,arg2,arg3):
    log_file = open("worker_{arg1}_{arg2}_{arg3}.log", "w")
    print(f"args: {arg1} {arg2} {arg3}", file=log_file, flush=True)

pool = multiprocessing.Pool(processes=8)
parallel_out = pool.starmap(worker, zip(list1, list2, cycle([string1])))
pool.close()
pool.join()
```

### Add color to stdout
```
class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

print(f"{bcolors.OKGREEN}OK{bcolors.ENDC}")
print(f"{bcolors.FAIL}not found{bcolors.ENDC}")
```
### bitwise flags
#### check if flags contains 4
```
flag = 20
flag & 4 == 0 # false

flag = 48
flag & 4 == 0 # true
```
### Subprocess
#### write stdout to file, print stderr to screen
```
import subprocess as s
cmd = [command, arg1, arg2, arg3]
out = open(filename, "wb")
p = s.Popen(cmd, universal_newlines=True, stdout=out, stderr = s.PIPE)
mystderr = p.stderr.read()
print(mystderr)
p.communicate()
```


### Pip
automatically install a list of requirements **-> one-by-one <-**
```
#Windows
FOR /F %k in (requirements.txt) DO pip install %k
```
```
#Mac/Linux
cat requirements.txt | xargs -n 1 pip install
```


### Jupyter lab
#### Collaborative notebook
```
#Start Jupyter lab on the server:
conda create --name Jlab python=3.9
conda activate Jlab
conda install -c conda-forge jupyterlab
python -m pip install jupyterlab-link-share

#Do port forwarding on the client terminal:
ssh -L 8888:localhost:8888 first.last@server.address
```
### Pandas
read from excel file
```
pandas.read_excel(io, sheet_name=0, *, header=0, names=None, index_col=None, usecols=None, squeeze=None, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, parse_dates=False, date_parser=None, thousands=None, decimal='.', comment=None, skipfooter=0, convert_float=None, mangle_dupe_cols=True, storage_options=None)
```
create a single-column dataframe
```
df = pd.DataFrame({'column_title': mylist})
df = pd.DataFrame(data = {'column_title':mylist }, index = mylist2) # with index
```
iterater over df by rows
```
for index, row in df.iterrows():
    #do something
```
accumulate data （rows） and then use it to create a dataframe#
```
data = []
for a, b, c in some_function_that_yields_data():
    data.append([a, b, c])

df = pd.DataFrame(data, columns=['A', 'B', 'C'])
```
### Files
#### Copy files
```
import shutil
shutil.copyfile(src, dst)
# 2nd option
shutil.copy(src, dst)  # dst can be a folder; use shutil.copy2() to preserve timestamp
```
#### read files
```
oneline = fileHandle.readline() #read oneline
entirefile = fileHandle.read() #read entire file
```
#### Check gzip file integrity
```
def check_gzip_integrity(filepath):
    import gzip
    chunksize = 1024 * 1024
    with gzip.open(filepath) as g:
        try:
            while g.read(chunksize):
                pass
            return True
        except:
            #print("Corrupted!", e)
            return False
```
#### Merge gzipped files
```
def merge_files_and_rename(old_file_list, new_file):

    print(f"Merging:")

    old_file_list = old_file_list.split(',')

    # Create the output directory if it doesn't exist
    out_dir = os.path.dirname(new_file)
    os.makedirs(out_dir, exist_ok=True)

    # Remove output file if it already exists
    if os.path.exists(new_file):
        os.remove(new_file)

    with gzip.open(new_file, 'wb') as outfile:
        # Loop through each file in the file list
        for file_name in old_file_list:
            print(f"    {file_name}")
            # Open the gzipped file for reading in binary mode
            with gzip.open(os.path.join(file_name), 'rb') as infile:
                # Read the contents of the file
                file_contents = infile.read()
                # Check if the last character of the file is a newline
                if file_contents[-1:] != b'\n':
                    # Append a newline character to the end of the file
                    file_contents += b'\n'
                # Write the contents of the file to the output file
                outfile.write(file_contents)
    print(f"    into a {bcolors.WARNING}new file{bcolors.ENDC}: {new_file}")
```

### working dir
Change working directory to the location of this script
```
abspath = os.path.abspath(__file__)
dname = os.path.dirname(abspath)
os.chdir(dname)
```

### Conda
creat environment
```
conda create --name py39 python=3.9
```
creat environment from file
```
conda env create -f environment.yml
```
rename environment
```
conda rename -n old_name -d new_name
```
### Matplotlib
fig, ax = plt.subplots(1, 3, figsize=(10, 3))
plt.suptitle('')
for j in range(''):
    ax[j].imshow('')
